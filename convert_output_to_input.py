from typing import List, Tuple, Dict
import argparse


class Atom():
    def __init__(self, atom_type: str, position: Tuple[float, float, float]):
        self.type = atom_type
        self.position = position

class Converter():
    atoms: List[Atom] = None
    num_of_atoms: int = None
    atom_types: List[str] = None
    atom_masses: Dict[str, float] = {
        "H_HOH": 1.0078,
        "O_HOH": 15.9994,
        "C_HOH": 12.011,
        "F_HOH": 18.998403,
        "H_UNL": 1.0078,
        "O_UNL": 15.9994,
        "C_UNL": 12.011,
        "F_UNL": 18.998403,
    }
    atom_type_names: Dict[str, str] = {
        "H_HOH": "H of water",
        "O_HOH": "O of water",
        "C_HOH": "C of water",
        "F_HOH": "F of water",
        "H_UNL": "H of pfoah",
        "O_UNL": "O of pfoah",
        "C_UNL": "C of pfoah",
        "F_UNL": "F of pfoah",
    }

    @staticmethod
    def analyze(atoms: List[Atom]) -> None:
        Converter.atoms = atoms
        Converter.num_of_atoms = len(atoms)
        Converter.atom_types = []
        for atom in atoms:
            if atom.type not in Converter.atom_types:
                Converter.atom_types.append(atom.type)

    @staticmethod
    def generate() -> List[str]:
        # Temp mapping for atom_type to index
        atom_types_map: [str, int] = {}

        # Result string
        res = []

        # Header
        res.append("# water and pfoah on sio2 slab")
        res.append("")

        # Atom information
        padding = len(str(Converter.num_of_atoms)) + 1
        res.append(str(Converter.num_of_atoms).ljust(padding) + "atoms")
        res.append(str(len(Converter.atom_types)).ljust(padding) + "atom types")
        res.append("")
        
        # Atom masses
        padding = 14
        res.append("Masses")
        res.append("")
        for type_index, atom_type in enumerate(Converter.atom_types):
            atom_types_map[atom_type] = type_index
            s = f"{type_index + 1} {Converter.atom_masses[atom_type]}".ljust(padding) + " | ";
            s += Converter.atom_type_names[atom_type]
            res.append(s)
        res.append("")

        # Atoms
        padding = 7
        res.append("Atoms")
        res.append("")
        for atom_index, atom in enumerate(Converter.atoms):
            s = str(atom_index + 1).ljust(padding)
            s += str(atom_types_map[atom.type]).ljust(padding)
            s += "0".ljust(padding)
            s += " ".join([str(fpos).ljust(padding) for fpos in atom.position])
            res.append(s)

        return res

class Parser():
    lines: List[str] = None
    atoms: List[Atom] = None

    @staticmethod
    def read_file(filepath: str) -> None:
        Parser.lines = []

        # Open filepath and extract all the lines from the file
        with open(filepath, "r") as file:
            for line in file:
                Parser.lines.append(line.strip())

    @staticmethod
    def parse() -> None:
        Parser.atoms = []
        for line in Parser.lines:
            # Split each line into parts
            parts = [part.strip() for part in line.split(" ") if part != ""]

            # If the line is not an atom, then ignore the line
            if parts[0] != "HETATM": continue

            atom_type = f"{parts[2]}_{parts[3]}"
            atom_pos = (float(parts[6]), float(parts[7]), float(parts[8]))
            atom = Atom(atom_type, atom_pos)
            Parser.atoms.append(atom)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="converts pdb file to input file")
    parser.add_argument("filepath", help="path of the input file generated by packmol")
    parser.add_argument("--out", "-o", help="path of the output file, default path is the current directory, and default filename is output.txt", default="output.txt")
    args = parser.parse_args()

    Parser.read_file(args.filepath)
    Parser.parse()
    Converter.analyze(Parser.atoms)

    with open(args.out, "w+") as file:
        file.write("\n".join(Converter.generate()))
    
    








